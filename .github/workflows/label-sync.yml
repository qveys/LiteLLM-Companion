name: Label Sync

on:
  push:
    branches: [main]
    paths: [".github/labels.yml"]
  schedule:
    - cron: "0 6 * * 1"
  workflow_dispatch:

permissions:
  contents: read
  issues: write

concurrency:
  group: label-sync-${{ github.repository }}
  cancel-in-progress: true

jobs:
  sync-labels:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Sync labels from .github/labels.yml
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const isPush = context.eventName === 'push';
            const mode = isPush ? 'auto-fix' : 'report-only';

            core.info(`Mode: ${mode} (trigger: ${context.eventName})`);

            // â”€â”€ parse labels.yml â”€â”€

            let desired;
            try {
              const raw = fs.readFileSync('.github/labels.yml', 'utf8');
              desired = yaml.load(raw);
              if (!Array.isArray(desired)) {
                core.setFailed('labels.yml must be a YAML array of label objects.');
                return;
              }
            } catch (err) {
              core.setFailed(`Failed to parse labels.yml: ${err.message}`);
              return;
            }

            const desiredMap = new Map();
            for (const label of desired) {
              if (!label.name) {
                core.warning('Skipping label entry without a name.');
                continue;
              }
              desiredMap.set(label.name, {
                color: (label.color || '').replace(/^#/, ''),
                description: label.description || '',
              });
            }

            core.info(`Parsed ${desiredMap.size} labels from labels.yml`);

            // â”€â”€ fetch current labels â”€â”€

            const currentLabels = await github.paginate(github.rest.issues.listLabelsForRepo, {
              owner,
              repo,
              per_page: 100,
            });

            const currentMap = new Map();
            for (const label of currentLabels) {
              currentMap.set(label.name, {
                color: (label.color || '').replace(/^#/, ''),
                description: label.description || '',
              });
            }

            core.info(`Fetched ${currentMap.size} labels from GitHub`);

            // â”€â”€ convention patterns (substring matches via .includes()) â”€â”€

            const knownPatterns = [
              'ðŸš¦ Status:', 'ðŸ”¥ Priority:', 'â±ï¸ Effort:',
              ' Type:', 'ðŸ§© Area:', 'ðŸ§ª Area:', 'ðŸ“ Area:', 'ðŸ Area:',
              'ðŸŽ¯ Detector:', 'ðŸ§· Meta:', 'ðŸ—ºï¸ Roadmap:', 'ðŸ¤– AC:',
            ];

            // â”€â”€ classify â”€â”€

            const missing = [];
            const drifted = [];
            const violations = [];

            for (const [name, spec] of desiredMap) {
              const current = currentMap.get(name);
              if (!current) {
                missing.push({ name, ...spec });
              } else if (current.color !== spec.color || current.description !== spec.description) {
                drifted.push({
                  name,
                  expected: spec,
                  actual: current,
                });
              }

              const matchesPrefix = knownPatterns.some((p) => name.includes(p));
              if (!matchesPrefix) {
                violations.push(name);
              }
            }

            const orphansSafe = [];
            const orphansInUse = [];

            for (const [name] of currentMap) {
              if (!desiredMap.has(name)) {
                let inUse = true;
                try {
                  const result = await github.rest.search.issuesAndPullRequests({
                    q: `repo:${owner}/${repo} is:open label:"${name}"`,
                    per_page: 1,
                  });
                  inUse = result.data.total_count > 0;
                } catch (err) {
                  core.warning(`Search failed for orphan "${name}", conservatively keeping: ${err.message}`);
                  inUse = true;
                }

                if (inUse) {
                  orphansInUse.push(name);
                } else {
                  orphansSafe.push(name);
                }
              }
            }

            core.info(`Missing: ${missing.length}, Drifted: ${drifted.length}, Orphans safe: ${orphansSafe.length}, Orphans in-use: ${orphansInUse.length}, Violations: ${violations.length}`);

            // â”€â”€ apply changes (auto-fix mode) â”€â”€

            const applied = { created: 0, updated: 0, deleted: 0 };

            if (mode === 'auto-fix') {
              for (const label of missing) {
                try {
                  await github.rest.issues.createLabel({
                    owner, repo,
                    name: label.name,
                    color: label.color,
                    description: label.description,
                  });
                  applied.created++;
                  core.info(`Created: ${label.name}`);
                } catch (err) {
                  core.warning(`Failed to create "${label.name}": ${err.message}`);
                }
              }

              for (const item of drifted) {
                try {
                  await github.rest.issues.updateLabel({
                    owner, repo,
                    name: item.name,
                    color: item.expected.color,
                    description: item.expected.description,
                  });
                  applied.updated++;
                  core.info(`Updated: ${item.name}`);
                } catch (err) {
                  core.warning(`Failed to update "${item.name}": ${err.message}`);
                }
              }

              for (const name of orphansSafe) {
                try {
                  await github.rest.issues.deleteLabel({ owner, repo, name });
                  applied.deleted++;
                  core.info(`Deleted orphan: ${name}`);
                } catch (err) {
                  if (err.status !== 404) {
                    core.warning(`Failed to delete "${name}": ${err.message}`);
                  }
                }
              }

              core.info(`Applied â€” created: ${applied.created}, updated: ${applied.updated}, deleted: ${applied.deleted}`);
            }

            // â”€â”€ job summary â”€â”€

            const lines = [`## Label Sync â€” ${mode}\n`];

            if (missing.length > 0) {
              lines.push(`### ${mode === 'auto-fix' ? 'Created' : 'Missing'} (${missing.length})\n`);
              lines.push('| Label | Color | Description |');
              lines.push('|-------|-------|-------------|');
              for (const l of missing) {
                lines.push(`| ${l.name} | \`#${l.color}\` | ${l.description} |`);
              }
              lines.push('');
            }

            if (drifted.length > 0) {
              lines.push(`### ${mode === 'auto-fix' ? 'Updated' : 'Drifted'} (${drifted.length})\n`);
              lines.push('| Label | Field | Expected | Actual |');
              lines.push('|-------|-------|----------|--------|');
              for (const d of drifted) {
                if (d.expected.color !== d.actual.color) {
                  lines.push(`| ${d.name} | color | \`#${d.expected.color}\` | \`#${d.actual.color}\` |`);
                }
                if (d.expected.description !== d.actual.description) {
                  lines.push(`| ${d.name} | description | ${d.expected.description} | ${d.actual.description} |`);
                }
              }
              lines.push('');
            }

            if (orphansSafe.length > 0) {
              lines.push(`### ${mode === 'auto-fix' ? 'Deleted orphans' : 'Orphans â€” safe to delete'} (${orphansSafe.length})\n`);
              for (const name of orphansSafe) {
                lines.push(`- ${name}`);
              }
              lines.push('');
            }

            if (orphansInUse.length > 0) {
              lines.push(`### Orphans â€” in use (${orphansInUse.length})\n`);
              lines.push('> These labels are on GitHub but not in `labels.yml`, and have open issues/PRs.\n');
              for (const name of orphansInUse) {
                lines.push(`- ${name}`);
              }
              lines.push('');
            }

            if (violations.length > 0) {
              lines.push(`### Convention warnings (${violations.length})\n`);
              lines.push('> Labels in `labels.yml` that don\'t match a known prefix.\n');
              for (const name of violations) {
                lines.push(`- ${name}`);
              }
              lines.push('');
            }

            const hasDrift = missing.length > 0 || drifted.length > 0 || orphansSafe.length > 0 || orphansInUse.length > 0;

            if (!hasDrift && violations.length === 0) {
              lines.push('All labels are in sync. No drift detected.');
            }

            await core.summary.addRaw(lines.join('\n')).write();

            // â”€â”€ manage drift issue â”€â”€

            const driftTitle = 'Label drift detected';
            const driftLabel = 'ðŸ§© Area: CI';

            if (mode === 'report-only' && !hasDrift) {
              const existing = await github.rest.issues.listForRepo({
                owner, repo,
                state: 'open',
                labels: driftLabel,
                per_page: 100,
              });
              const driftIssue = existing.data.find((i) => i.title === driftTitle);
              if (driftIssue) {
                await github.rest.issues.update({
                  owner, repo,
                  issue_number: driftIssue.number,
                  state: 'closed',
                  state_reason: 'completed',
                });
                core.info(`Closed resolved drift issue #${driftIssue.number}`);
              }
            }

            if (mode === 'report-only' && hasDrift) {
              const body = lines.join('\n');
              const existing = await github.rest.issues.listForRepo({
                owner, repo,
                state: 'open',
                labels: driftLabel,
                per_page: 100,
              });
              const driftIssue = existing.data.find((i) => i.title === driftTitle);

              if (driftIssue) {
                await github.rest.issues.update({
                  owner, repo,
                  issue_number: driftIssue.number,
                  body,
                });
                core.info(`Updated drift issue #${driftIssue.number}`);
              } else {
                const created = await github.rest.issues.create({
                  owner, repo,
                  title: driftTitle,
                  body,
                  labels: [driftLabel],
                });
                core.info(`Created drift issue #${created.data.number}`);
              }
            }

            if (mode === 'auto-fix') {
              const existing = await github.rest.issues.listForRepo({
                owner, repo,
                state: 'open',
                labels: driftLabel,
                per_page: 100,
              });
              const driftIssue = existing.data.find((i) => i.title === driftTitle);
              if (driftIssue) {
                await github.rest.issues.update({
                  owner, repo,
                  issue_number: driftIssue.number,
                  state: 'closed',
                  state_reason: 'completed',
                });
                core.info(`Closed stale drift issue #${driftIssue.number}`);
              }
            }
