name: Label Lifecycle

on:
  issues:
    types: [opened, reopened, edited, assigned, unassigned, closed]
  pull_request:
    types: [opened, reopened, edited, synchronize, review_requested, ready_for_review, converted_to_draft, closed]
  pull_request_review:
    types: [submitted]
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write
  pull-requests: write

concurrency:
  group: label-lifecycle-${{ github.repository }}-${{ github.event.issue.number || github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  orchestrate-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Apply triage and status transitions
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const statusPrefix = 'ğŸš¦ Status:';
            const effortPrefix = 'â±ï¸ Effort:';
            const typeMarker = ' Type:';

            const preserveManualStatuses = new Set([
              'ğŸš¦ Status: Blocked',
              'ğŸš¦ Status: Needs Info',
            ]);

            const terminalStatuses = new Set([
              'ğŸš¦ Status: Fixed',
              'ğŸš¦ Status: Invalid',
              'ğŸš¦ Status: Duplicate',
              "ğŸš¦ Status: Won't Fix",
            ]);

            // â”€â”€ helpers â”€â”€

            function hasAnyPrefix(labels, prefix) {
              return labels.some((l) => l.startsWith(prefix));
            }

            function hasAnyType(labels) {
              return labels.some((l) => l.includes(typeMarker));
            }

            function pickTypeFromText(text) {
              const t = (text || '').toLowerCase();
              if (/\b(bug|error|crash|fail|broken|regression)\b/.test(t)) return 'ğŸ Type: Bug';
              if (/\b(feature|implement|new capability)\b/.test(t)) return 'ğŸš€ Type: Feature';
              if (/\b(enhancement|improve|minor|tweak|small)\b/.test(t)) return 'âœ¨ Type: Enhancement';
              if (/\b(build|workflow|pipeline|ci|github action|release)\b/.test(t)) return 'ğŸ—ï¸ Type: Build';
              if (/\b(doc|readme|documentation|guide)\b/.test(t)) return 'ğŸ“š Type: Documentation';
              if (/\b(test|spec|coverage|e2e|unit|pytest)\b/.test(t)) return 'ğŸ§ª Type: Test';
              if (/\b(deps|dependency|bump)\b/.test(t)) return 'ğŸ“¦ Type: Dependency';
              if (/\b(chore|cleanup|housekeeping)\b/.test(t)) return 'ğŸ§¹ Type: Chore';
              if (/\b(refactor|restructure|rename)\b/.test(t)) return 'ğŸ§¼ Type: Refactor';
              if (/\b(perf|performance|latency|optimize|slow)\b/.test(t)) return 'âš¡ Type: Performance';
              if (/\b(security|vuln|cve|xss|injection)\b/.test(t)) return 'ğŸ”’ Type: Security';
              return null;
            }

            function pickEffortFromChangedFiles(changedFiles) {
              if (changedFiles <= 3) return 'â±ï¸ Effort: Small';
              if (changedFiles <= 15) return 'â±ï¸ Effort: Medium';
              if (changedFiles <= 60) return 'â±ï¸ Effort: Large';
              return 'â±ï¸ Effort: X-Large';
            }

            // â”€â”€ API wrappers â”€â”€

            async function getExistingLabelSet() {
              const labels = await github.paginate(github.rest.issues.listLabelsForRepo, {
                owner,
                repo,
                per_page: 100,
              });
              return new Set(labels.map((l) => l.name));
            }

            async function getIssue(issue_number) {
              const { data } = await github.rest.issues.get({ owner, repo, issue_number });
              return data;
            }

            async function getPull(pull_number) {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number });
              return data;
            }

            function normalizeLabels(rawLabels) {
              return rawLabels.map((l) => (typeof l === 'string' ? l : l.name));
            }

            async function addLabels(issue_number, labels) {
              if (labels.length === 0) return;
              await github.rest.issues.addLabels({ owner, repo, issue_number, labels });
            }

            // â”€â”€ exclusive status setter â”€â”€

            async function setExclusiveStatus(issue_number, desiredStatus, options = {}) {
              const { force = false } = options;
              if (!existingLabels.has(desiredStatus)) {
                core.info(`Skip status '${desiredStatus}': label absent in repository.`);
                return;
              }

              const issue = await getIssue(issue_number);
              const currentLabels = normalizeLabels(issue.labels);
              const currentStatusLabels = currentLabels.filter((l) => l.startsWith(statusPrefix));

              if (!force) {
                const hasPreserved = currentStatusLabels.some((l) => preserveManualStatuses.has(l));
                if (hasPreserved && !terminalStatuses.has(desiredStatus)) {
                  core.info(`Skip status change on #${issue_number}: preserved manual status.`);
                  return;
                }
              }

              for (const label of currentStatusLabels) {
                if (label !== desiredStatus) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number, name: label });
                  } catch (err) {
                    if (err.status !== 404) throw err;
                    core.info(`Skip removing '${label}' on #${issue_number}: already absent.`);
                  }
                }
              }

              const latest = await getIssue(issue_number);
              const latestLabels = normalizeLabels(latest.labels);
              if (!latestLabels.includes(desiredStatus)) {
                await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [desiredStatus] });
              }

              core.info(`Set status on #${issue_number}: ${desiredStatus}`);
            }

            // â”€â”€ triage: auto-label on open/edit â”€â”€
            // Note: Area labeling is handled entirely by auto-label.yml
            // (actions/labeler) using .github/labeler.yml as single source of truth.

            async function applyTriage(issue_number, { isPR, title, body, changedFiles, labels }) {
              let currentLabels;
              if (labels && Array.isArray(labels)) {
                currentLabels = normalizeLabels(labels);
              } else {
                const issue = await getIssue(issue_number);
                currentLabels = normalizeLabels(issue.labels);
              }
              const labelsToAdd = [];

              if (!hasAnyPrefix(currentLabels, statusPrefix) && existingLabels.has('ğŸš¦ Status: Open')) {
                labelsToAdd.push('ğŸš¦ Status: Open');
              }

              if (!hasAnyType(currentLabels)) {
                const type = pickTypeFromText(`${title}\n${body || ''}`);
                if (type && existingLabels.has(type)) labelsToAdd.push(type);
              }

              if (isPR && !hasAnyPrefix(currentLabels, effortPrefix)) {
                const effort = pickEffortFromChangedFiles(changedFiles || 0);
                if (existingLabels.has(effort)) labelsToAdd.push(effort);
              }

              const deduped = [...new Set(labelsToAdd)].filter((l) => existingLabels.has(l));
              await addLabels(issue_number, deduped);
              core.info(`Triage labels on #${issue_number}: ${deduped.join(', ') || '(none)'}`);
            }

            // â”€â”€ status transitions based on event â”€â”€

            function desiredStatusForEvent() {
              const event = context.eventName;
              const action = context.payload.action;
              const payloadLabels =
                event === 'issues'
                  ? normalizeLabels(context.payload.issue?.labels || [])
                  : event === 'pull_request' || event === 'pull_request_review'
                  ? normalizeLabels(context.payload.pull_request?.labels || [])
                  : [];
              const currentStatusLabels = payloadLabels.filter((l) => l.startsWith(statusPrefix));
              const hasTerminalStatus = currentStatusLabels.some((l) => terminalStatuses.has(l));

              if (event === 'issues') {
                if (action === 'opened' || action === 'reopened') return { status: 'ğŸš¦ Status: Open', force: false };
                if (action === 'assigned') return { status: 'ğŸš¦ Status: In Progress', force: false };
                if (action === 'unassigned') {
                  const remainingAssignees = Array.isArray(context.payload.issue?.assignees)
                    ? context.payload.issue.assignees.length
                    : 0;
                  if (remainingAssignees === 0) return { status: 'ğŸš¦ Status: Open', force: false };
                  return null;
                }
                if (action === 'closed') {
                  if (hasTerminalStatus) return null;
                  const reason = (context.payload.issue?.state_reason || '').toLowerCase();
                  if (reason === 'not_planned') return { status: "ğŸš¦ Status: Won't Fix", force: true };
                  if (reason === 'duplicate') return { status: 'ğŸš¦ Status: Duplicate', force: true };
                  return { status: 'ğŸš¦ Status: Fixed', force: true };
                }
              }

              if (event === 'pull_request') {
                if (action === 'opened' || action === 'reopened') {
                  const isDraft = Boolean(context.payload.pull_request?.draft);
                  return { status: isDraft ? 'ğŸš¦ Status: In Progress' : 'ğŸš¦ Status: Open', force: false };
                }
                if (action === 'converted_to_draft') return { status: 'ğŸš¦ Status: In Progress', force: false };
                if (action === 'synchronize') return { status: 'ğŸš¦ Status: In Progress', force: false };
                if (action === 'review_requested' || action === 'ready_for_review') {
                  return { status: 'ğŸš¦ Status: Review Needed', force: false };
                }
                if (action === 'closed') {
                  if (hasTerminalStatus) return null;
                  const merged = Boolean(context.payload.pull_request?.merged);
                  return merged
                    ? { status: 'ğŸš¦ Status: Fixed', force: true }
                    : { status: 'ğŸš¦ Status: On Hold', force: true };
                }
              }

              if (event === 'pull_request_review' && action === 'submitted') {
                const state = (context.payload.review.state || '').toLowerCase();
                if (state === 'changes_requested') return { status: 'ğŸš¦ Status: In Progress', force: true };
                if (state === 'approved') return { status: 'ğŸš¦ Status: Ready', force: true };
                if (state === 'commented') return null;
                return { status: 'ğŸš¦ Status: Review Needed', force: false };
              }

              return null;
            }

            // â”€â”€ "Needs Info" auto-resolve when author comments â”€â”€

            async function handleNeedsInfoResolutionByComment() {
              if (context.eventName !== 'issue_comment' || context.payload.action !== 'created') return;

              const issue_number = context.payload.issue.number;
              const commentBody = (context.payload.comment?.body || '').trim();
              if (!commentBody) return;

              const issue = await getIssue(issue_number);
              const labels = normalizeLabels(issue.labels);
              if (!labels.includes('ğŸš¦ Status: Needs Info')) return;

              const issueAuthor = issue.user?.login;
              const commenter = context.payload.comment?.user?.login;
              if (!issueAuthor || !commenter || issueAuthor !== commenter) {
                core.info('Needs Info unchanged: comment is not from issue/PR author.');
                return;
              }

              const isPR = Boolean(issue.pull_request);
              const nextStatus = isPR ? 'ğŸš¦ Status: Review Needed' : 'ğŸš¦ Status: Open';
              await setExclusiveStatus(issue_number, nextStatus, { force: true });
            }

            // â”€â”€ main â”€â”€

            function getIssueNumberFromEvent() {
              if (context.eventName === 'issues') return context.payload.issue.number;
              if (context.eventName === 'pull_request') return context.payload.pull_request.number;
              if (context.eventName === 'pull_request_review') return context.payload.pull_request.number;
              if (context.eventName === 'issue_comment') return context.payload.issue.number;
              return null;
            }

            const existingLabels = await getExistingLabelSet();
            const event = context.eventName;
            const action = context.payload.action;

            let isForkPR = false;
            if (context.payload.pull_request?.head?.repo?.full_name && context.payload.pull_request?.base?.repo?.full_name) {
              isForkPR = context.payload.pull_request.head.repo.full_name !== context.payload.pull_request.base.repo.full_name;
            } else if (event === 'issue_comment' && context.payload.issue?.pull_request) {
              const pr = await getPull(context.payload.issue.number);
              if (pr?.head?.repo?.full_name && pr?.base?.repo?.full_name) {
                isForkPR = pr.head.repo.full_name !== pr.base.repo.full_name;
              }
            }

            if (isForkPR && (event === 'pull_request' || event === 'pull_request_review' || (event === 'issue_comment' && context.payload.issue?.pull_request))) {
              core.info('Skip label lifecycle for fork pull requests (read-only token context).');
              return;
            }

            if (event === 'issues' && ['opened', 'reopened', 'edited'].includes(action)) {
              const issue = context.payload.issue;
              await applyTriage(issue.number, {
                isPR: false,
                title: issue.title,
                body: issue.body,
                changedFiles: 0,
                labels: issue.labels,
              });
            }

            if (event === 'pull_request' && ['opened', 'reopened', 'edited'].includes(action)) {
              const pr = await getPull(context.payload.pull_request.number);
              await applyTriage(pr.number, {
                isPR: true,
                title: pr.title,
                body: pr.body,
                changedFiles: pr.changed_files || 0,
                labels: pr.labels,
              });
            }

            const issue_number = getIssueNumberFromEvent();
            if (issue_number) {
              const desired = desiredStatusForEvent();
              if (desired) {
                await setExclusiveStatus(issue_number, desired.status, { force: desired.force });
              }
            }

            await handleNeedsInfoResolutionByComment();
